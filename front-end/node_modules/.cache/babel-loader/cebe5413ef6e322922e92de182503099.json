{"ast":null,"code":"'use strict'; // An enumeration of server types we know about\n\nconst ServerType = {\n  Standalone: 'Standalone',\n  Mongos: 'Mongos',\n  PossiblePrimary: 'PossiblePrimary',\n  RSPrimary: 'RSPrimary',\n  RSSecondary: 'RSSecondary',\n  RSArbiter: 'RSArbiter',\n  RSOther: 'RSOther',\n  RSGhost: 'RSGhost',\n  Unknown: 'Unknown'\n};\nconst WRITABLE_SERVER_TYPES = new Set([ServerType.RSPrimary, ServerType.Standalone, ServerType.Mongos]);\nconst DATA_BEARING_SERVER_TYPES = new Set([ServerType.RSPrimary, ServerType.RSSecondary, ServerType.Mongos, ServerType.Standalone]);\nconst ISMASTER_FIELDS = ['minWireVersion', 'maxWireVersion', 'maxBsonObjectSize', 'maxMessageSizeBytes', 'maxWriteBatchSize', 'compression', 'me', 'hosts', 'passives', 'arbiters', 'tags', 'setName', 'setVersion', 'electionId', 'primary', 'logicalSessionTimeoutMinutes', 'saslSupportedMechs', '__nodejs_mock_server__', '$clusterTime'];\n/**\n * The client's view of a single server, based on the most recent ismaster outcome.\n *\n * Internal type, not meant to be directly instantiated\n */\n\nclass ServerDescription {\n  /**\n   * Create a ServerDescription\n   * @param {String} address The address of the server\n   * @param {Object} [ismaster] An optional ismaster response for this server\n   * @param {Object} [options] Optional settings\n   * @param {Number} [options.roundTripTime] The round trip time to ping this server (in ms)\n   */\n  constructor(address, ismaster, options) {\n    options = options || {};\n    ismaster = Object.assign({\n      minWireVersion: 0,\n      maxWireVersion: 0,\n      hosts: [],\n      passives: [],\n      arbiters: [],\n      tags: []\n    }, ismaster);\n    this.address = address;\n    this.error = options.error || null;\n    this.roundTripTime = options.roundTripTime || 0;\n    this.lastUpdateTime = Date.now();\n    this.lastWriteDate = ismaster.lastWrite ? ismaster.lastWrite.lastWriteDate : null;\n    this.opTime = ismaster.lastWrite ? ismaster.lastWrite.opTime : null;\n    this.type = parseServerType(ismaster); // direct mappings\n\n    ISMASTER_FIELDS.forEach(field => {\n      if (typeof ismaster[field] !== 'undefined') this[field] = ismaster[field];\n    }); // normalize case for hosts\n\n    if (this.me) this.me = this.me.toLowerCase();\n    this.hosts = this.hosts.map(host => host.toLowerCase());\n    this.passives = this.passives.map(host => host.toLowerCase());\n    this.arbiters = this.arbiters.map(host => host.toLowerCase());\n  }\n\n  get allHosts() {\n    return this.hosts.concat(this.arbiters).concat(this.passives);\n  }\n  /**\n   * @return {Boolean} Is this server available for reads\n   */\n\n\n  get isReadable() {\n    return this.type === ServerType.RSSecondary || this.isWritable;\n  }\n  /**\n   * @return {Boolean} Is this server data bearing\n   */\n\n\n  get isDataBearing() {\n    return DATA_BEARING_SERVER_TYPES.has(this.type);\n  }\n  /**\n   * @return {Boolean} Is this server available for writes\n   */\n\n\n  get isWritable() {\n    return WRITABLE_SERVER_TYPES.has(this.type);\n  }\n\n}\n/**\n * Parses an `ismaster` message and determines the server type\n *\n * @param {Object} ismaster The `ismaster` message to parse\n * @return {ServerType}\n */\n\n\nfunction parseServerType(ismaster) {\n  if (!ismaster || !ismaster.ok) {\n    return ServerType.Unknown;\n  }\n\n  if (ismaster.isreplicaset) {\n    return ServerType.RSGhost;\n  }\n\n  if (ismaster.msg && ismaster.msg === 'isdbgrid') {\n    return ServerType.Mongos;\n  }\n\n  if (ismaster.setName) {\n    if (ismaster.hidden) {\n      return ServerType.RSOther;\n    } else if (ismaster.ismaster) {\n      return ServerType.RSPrimary;\n    } else if (ismaster.secondary) {\n      return ServerType.RSSecondary;\n    } else if (ismaster.arbiterOnly) {\n      return ServerType.RSArbiter;\n    } else {\n      return ServerType.RSOther;\n    }\n  }\n\n  return ServerType.Standalone;\n}\n\nmodule.exports = {\n  ServerDescription,\n  ServerType\n};","map":null,"metadata":{},"sourceType":"script"}